<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>极简数独 - 浅蓝轨道修复版</title>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --primary-bg: #FDFDFD;
            --text-main: #020617;
            --accent-blue: #1d4ed8;
            --track-blue: #D1E5FF; /* 核心：要求的浅蓝色 */
            --line-black: #020617;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-main);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: system-ui, sans-serif;
            align-items: center;
        }

        header {
            flex: 0 0 12vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .title {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 3.5rem;
            margin: 0;
            user-select: none;
        }

        main {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        /* 绝对固定棋盘尺寸 */
        .board-container {
            position: relative;
            width: 60vh; 
            height: 60vh;
            border: 3px solid var(--line-black);
            box-sizing: content-box;
            background: var(--primary-bg);
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 100%;
            height: 100%;
        }

        .cell {
            box-sizing: border-box;
            border: 0.5px solid var(--line-black);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 3.5vh; 
            outline: none;
            background: var(--primary-bg);
        }

        /* 九宫格粗线条 */
        .cell:nth-child(3n):not(:nth-child(9n)) { border-right-width: 3px; }
        .cell:nth-child(n+19):nth-child(-n+27),
        .cell:nth-child(n+46):nth-child(-n+54) { border-bottom-width: 3px; }

        #drawing-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            touch-action: none;
            cursor: crosshair;
        }

        footer {
            flex: 0 0 25vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2.5rem;
            width: 100%;
        }

        /* --- 浅蓝色轨道滑动条核心修复 --- */
        .slider-wrapper {
            width: 240px;
            padding: 10px 0;
            position: relative;
        }

        /* 底部增加一层物理背景线，确保浅蓝色 100% 可见 */
        .slider-wrapper::before {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            height: 4px;
            background: var(--track-blue);
            transform: translateY(-50%);
            border-radius: 2px;
            z-index: 0;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            position: relative;
            z-index: 1; /* 在蓝色轨道之上 */
            cursor: pointer;
        }

        /* 移除默认轨道，由父级背景承担蓝色显示 */
        input[type=range]::-webkit-slider-runnable-track {
            background: transparent;
            height: 4px;
        }
        input[type=range]::-moz-range-track {
            background: transparent;
            height: 4px;
        }

        /* 还原滑块样式 */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 22px;
            width: 22px;
            border-radius: 50%;
            background: #ffffff;
            border: 1.5px solid #94a3b8;
            margin-top: -9px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        input[type=range]::-moz-range-thumb {
            height: 22px;
            width: 22px;
            border-radius: 50%;
            background: #ffffff;
            border: 1.5px solid #94a3b8;
        }

        .mode-hint {
            display: flex;
            justify-content: space-between;
            width: 240px;
            font-size: 0.75rem;
            color: #94a3b8;
            letter-spacing: 2px;
            margin-top: -10px;
        }

        /* 按钮样式 */
        .btn-group {
            display: flex;
            gap: 3rem;
            align-items: center;
        }
        .btn-main {
            background-color: #eff6ff;
            color: var(--accent-blue);
            padding: 12px 26px;
            border-radius: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .btn-sub {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #475569;
            cursor: pointer;
        }

        .edit-active .cell:focus {
            background-color: #f1f5f9;
            box-shadow: inset 0 0 0 2px var(--accent-blue);
        }
        .edit-active #drawing-canvas { pointer-events: none; opacity: 0.2; }
    </style>
</head>
<body>

    <header>
        <h1 class="title">数独</h1>
    </header>

    <main>
        <div class="board-container" id="board-box">
            <div class="sudoku-grid" id="grid"></div>
            <canvas id="drawing-canvas"></canvas>
        </div>
    </main>

    <footer>
        <div class="slider-wrapper">
            <input type="range" id="mode-slider" min="0" max="1" step="1" value="0">
        </div>
        <div class="mode-hint">
            <span>书写</span>
            <span>橡皮</span>
        </div>

        <div class="btn-group">
            <div class="btn-main" id="edit-toggle">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 113 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                <span id="edit-text">设置已知数</span>
            </div>
            <div class="btn-sub" id="clear-canvas">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                <span>清空笔迹</span>
            </div>
        </div>
    </footer>

    <script>
        const grid = document.getElementById('grid');
        const boardBox = document.getElementById('board-box');
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const modeSlider = document.getElementById('mode-slider');
        const editBtn = document.getElementById('edit-toggle');
        const clearBtn = document.getElementById('clear-canvas');
        const editText = document.getElementById('edit-text');

        let isEditMode = false;
        let isMouseDown = false;
        let cells = [];

        // 默认已知数布局
        const puzzle = [
            5, 3, 0, 0, 7, 0, 0, 0, 0,
            6, 0, 0, 1, 9, 5, 0, 0, 0,
            0, 9, 8, 0, 0, 0, 0, 6, 0,
            8, 0, 0, 0, 6, 0, 0, 0, 3,
            4, 0, 0, 8, 0, 3, 0, 0, 1,
            7, 0, 0, 0, 2, 0, 0, 0, 6,
            0, 6, 0, 0, 0, 0, 2, 8, 0,
            0, 0, 0, 4, 1, 9, 0, 0, 5,
            0, 0, 0, 0, 8, 0, 0, 7, 9
        ];

        function initGrid() {
            grid.innerHTML = '';
            puzzle.forEach((num, i) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.innerText = num !== 0 ? num : '';
                cell.dataset.index = i;
                grid.appendChild(cell);
                cells.push(cell);
            });
        }

        // 模式切换
        function updateMode() {
            if (modeSlider.value == 0) {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = '#1d4ed8';
                ctx.lineWidth = 4;
            } else {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 30;
            }
        }
        modeSlider.addEventListener('input', updateMode);

        // 画布书写交互
        function setupCanvas() {
            canvas.width = 1200; canvas.height = 1200;
            ctx.lineJoin = 'round'; ctx.lineCap = 'round';
            updateMode();
        }

        function getXY(e) {
            const rect = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (cx - rect.left) * (canvas.width / rect.width),
                y: (cy - rect.top) * (canvas.height / rect.height)
            };
        }

        const startDrawing = (e) => {
            if (isEditMode) return;
            isMouseDown = true;
            const {x, y} = getXY(e);
            ctx.beginPath();
            ctx.moveTo(x, y);
        };

        const drawMove = (e) => {
            if (!isMouseDown || isEditMode) return;
            const {x, y} = getXY(e);
            ctx.lineTo(x, y);
            ctx.stroke();
        };

        const stopDrawing = () => { isMouseDown = false; };

        canvas.addEventListener('mousedown', startDrawing);
        window.addEventListener('mousemove', drawMove);
        window.addEventListener('mouseup', stopDrawing);

        canvas.addEventListener('touchstart', (e) => {
            if (!isEditMode) e.preventDefault();
            startDrawing(e);
        }, {passive: false});
        canvas.addEventListener('touchmove', (e) => {
            if (!isEditMode) e.preventDefault();
            drawMove(e);
        }, {passive: false});
        canvas.addEventListener('touchend', stopDrawing);

        // 设置模式
        editBtn.addEventListener('click', () => {
            isEditMode = !isEditMode;
            boardBox.classList.toggle('edit-active', isEditMode);
            if (isEditMode) {
                editText.innerText = "保存布局";
                cells.forEach(c => c.tabIndex = 0);
                cells[0].focus();
            } else {
                editText.innerText = "设置已知数";
                cells.forEach(c => c.tabIndex = -1);
            }
        });

        boardBox.addEventListener('keydown', (e) => {
            if (!isEditMode) return;
            const target = e.target;
            const idx = parseInt(target.dataset.index);
            if (e.key >= '1' && e.key <= '9') target.innerText = e.key;
            else if (e.key === 'Backspace') target.innerText = '';
            else if (e.key.startsWith('Arrow')) {
                e.preventDefault();
                let next = idx;
                if (e.key === 'ArrowUp') next -= 9;
                if (e.key === 'ArrowDown') next += 9;
                if (e.key === 'ArrowLeft') next -= 1;
                if (e.key === 'ArrowRight') next += 1;
                if (next >= 0 && next < 81) cells[next].focus();
            }
        });

        clearBtn.addEventListener('click', () => ctx.clearRect(0, 0, canvas.width, canvas.height));

        initGrid();
        setupCanvas();
    </script>
</body>
</html>
