<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seamless Loop Fan Layout</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: #3559c0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        .card-container {
            position: relative;
            width: 100%;
            height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: translateY(-50px);
        }

        :root {
            --card-width: 200px;
            --card-height: 280px;
            --step: 230px; 
        }

        .card {
            width: var(--card-width);
            height: var(--card-height);
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: 800;
            color: rgba(0,0,0,0.3);
            user-select: none;
            cursor: pointer;

            /* 默认开启过渡，JS会在特定情况下暂时关闭它 */
            transition: transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1), left 0.5s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.5s;
        }

        /* === 可见区域 (-3 到 3) === */

        /* Center (0) */
        .card[data-pos="0"] {
            z-index: 10;
            transform: translate(-50%, -50%) translateY(0px) rotate(0deg) scale(1.05);
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
            border: 4px solid rgba(255,255,255,0.8);
            color: rgba(255,255,255,0.9);
            opacity: 1;
        }

        /* 1st Layer */
        .card[data-pos="1"] { z-index: 9; left: calc(50% + var(--step)); transform: translate(-50%, -50%) translateY(20px) rotate(5deg); opacity: 1;}
        .card[data-pos="-1"] { z-index: 9; left: calc(50% - var(--step)); transform: translate(-50%, -50%) translateY(20px) rotate(-5deg); opacity: 1;}

        /* 2nd Layer */
        .card[data-pos="2"] { z-index: 8; left: calc(50% + var(--step) * 2); transform: translate(-50%, -50%) translateY(60px) rotate(10deg); opacity: 1;}
        .card[data-pos="-2"] { z-index: 8; left: calc(50% - var(--step) * 2); transform: translate(-50%, -50%) translateY(60px) rotate(-10deg); opacity: 1;}

        /* 3rd Layer */
        .card[data-pos="3"] { z-index: 7; left: calc(50% + var(--step) * 3); transform: translate(-50%, -50%) translateY(120px) rotate(15deg); opacity: 1;}
        .card[data-pos="-3"] { z-index: 7; left: calc(50% - var(--step) * 3); transform: translate(-50%, -50%) translateY(120px) rotate(-15deg); opacity: 1;}

        /* === 缓冲区 (关键修改) === */
        /* 为了防止穿帮，我们需要让卡片滑出视野后再消失，或者在视野外就位后再滑入 */

        /* 右侧隐藏区：放在比 3 更远的地方 */
        .card[data-pos="4"] {
            z-index: 0;
            left: calc(50% + var(--step) * 4); 
            transform: translate(-50%, -50%) translateY(120px) rotate(20deg);
            opacity: 0;
            pointer-events: none;
        }

        /* 左侧隐藏区：放在比 -3 更远的地方 */
        .card[data-pos="-4"] {
            z-index: 0;
            left: calc(50% - var(--step) * 4);
            transform: translate(-50%, -50%) translateY(120px) rotate(-20deg);
            opacity: 0;
            pointer-events: none;
        }

        .controls {
            position: absolute;
            bottom: 50px;
            display: flex;
            gap: 40px;
            z-index: 100;
        }

        button {
            padding: 12px 30px;
            border-radius: 30px;
            border: 2px solid rgba(255,255,255,0.6);
            background: rgba(255,255,255,0.1);
            color: white;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: 0.3s;
        }

        button:hover {
            background: white;
            color: #3559c0;
        }
    </style>
</head>
<body>

    <div class="card-container" id="container"></div>

    <div class="controls">
        <button id="prevBtn">← PREV</button>
        <button id="nextBtn">NEXT →</button>
    </div>

    <script>
        const container = document.getElementById('container');
        const totalCards = 14; 
        const colors = [
            '#FF9F43', '#FECA57', '#FF6B6B', '#48DBFB', 
            '#1DD1A1', '#F368E0', '#00D2D3', '#54A0FF', 
            '#5F27CD', '#C8D6E5', '#576574', '#222F3E'
        ];
        
        let activeIndex = 0; 

        // 初始化
        function init() {
            for (let i = 0; i < totalCards; i++) {
                const card = document.createElement('div');
                card.className = 'card';
                const num = (i + 1).toString().padStart(3, '0');
                card.textContent = `#${num}`;
                const color = colors[i % colors.length];
                card.style.background = `linear-gradient(135deg, ${color} 0%, ${adjustColor(color, -30)} 100%)`;
                
                // 记录当前卡片在视图中的逻辑位置，用于检测瞬移
                // 初始所有卡片都在后面
                card.dataset.lastPos = 0; 

                card.addEventListener('click', () => {
                    const diff = getShortestDirection(activeIndex, i, totalCards);
                    activeIndex = (activeIndex + diff + totalCards) % totalCards;
                    update();
                });

                container.appendChild(card);
            }
            update();
        }

        function update() {
            const cards = document.querySelectorAll('.card');
            
            cards.forEach((card, index) => {
                // 1. 计算新位置
                let diff = getShortestDirection(activeIndex, index, totalCards);
                
                // 2. 限制 diff 范围在 -4 到 4 之间
                // 为什么要 -4 到 4？因为 3 是可见边缘，4 是不可见缓冲。
                // 超过 4 的全部归为 4，小于 -4 的全部归为 -4。
                // 这样所有右边的隐藏卡片都聚在 data-pos="4" 的位置，左边同理。
                let targetPos = diff;
                if (diff > 4) targetPos = 4;
                if (diff < -4) targetPos = -4;

                // 3. 【核心修复】检测是否发生“瞬移”
                // 获取上一次的位置
                const lastPos = parseInt(card.dataset.lastPos || 0);
                
                // 如果这次是 4 (右隐藏)，上次是 -4 (左隐藏)，或者反过来
                // 说明发生了循环回绕。这时候必须关掉动画！
                const isWrapping = Math.abs(targetPos - lastPos) > 4;

                if (isWrapping) {
                    // 暂时关闭动画
                    card.style.transition = 'none';
                    // 立即设置新位置
                    card.setAttribute('data-pos', targetPos);
                    
                    // 强制浏览器重排(Reflow)，让上面的设置立即生效（无动画）
                    void card.offsetWidth; 

                    // 恢复动画，以便下一次正常移动
                    // 使用 setTimeout 确保在下一帧恢复
                    setTimeout(() => {
                        card.style.transition = ''; 
                    }, 20);
                } else {
                    // 正常移动，保持动画开启
                    card.setAttribute('data-pos', targetPos);
                }

                // 更新记录，供下一次检测
                card.dataset.lastPos = targetPos;
            });
        }

        // 计算最短路径
        function getShortestDirection(from, to, length) {
            let diff = to - from;
            if (diff > length / 2) diff -= length;
            if (diff < -length / 2) diff += length;
            return diff;
        }

        function adjustColor(color, amount) {
            return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
        }

        document.getElementById('nextBtn').onclick = () => {
            activeIndex = (activeIndex + 1) % totalCards;
            update();
        };
        document.getElementById('prevBtn').onclick = () => {
            activeIndex = (activeIndex - 1 + totalCards) % totalCards;
            update();
        };
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') document.getElementById('nextBtn').click();
            if (e.key === 'ArrowLeft') document.getElementById('prevBtn').click();
        });

        init();
    </script>
</body>
</html>